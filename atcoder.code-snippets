{
  "@BIT": {
    "prefix": "@BIT",
    "body": [
      "pub struct BIT<",
      "    T: std::ops::AddAssign + std::ops::Sub<Output = T> + std::marker::Copy + std::fmt::Debug,",
      "> {",
      "    internal_array: Vec<T>,",
      "}",
      "impl<T: std::ops::AddAssign + std::ops::Sub<Output = T> + std::marker::Copy + std::fmt::Debug>",
      "    BIT<T>",
      "{",
      "    pub fn new(array: Vec<T>) -> BIT<T> {",
      "        let mut internal_array: Vec<T> = Vec::with_capacity(array.len());",
      "        if array.len() == 0 {",
      "            return BIT { internal_array };",
      "        }",
      "        let mut cum_sum: Vec<T> = Vec::with_capacity(array.len());",
      "        internal_array.push(array[0]);",
      "        cum_sum.push(array[0]);",
      "        let mut sum = array[0];",
      "        for i in 1..array.len() {",
      "            let mut lsb = 0;",
      "            let mut tmp_i = i + 1;",
      "            let mut now_digit = 1;",
      "            while lsb == 0 {",
      "                if tmp_i & 1 == 1 {",
      "                    lsb = now_digit;",
      "                } else {",
      "                    tmp_i >>= 1;",
      "                    now_digit += 1;",
      "                }",
      "            }",
      "            sum += array[i];",
      "            if lsb == 1 {",
      "                internal_array.push(array[i]);",
      "            } else {",
      "                if (1 << lsb) < i {",
      "                    internal_array.push(sum - cum_sum[i - (1 << (lsb - 1))]);",
      "                } else {",
      "                    internal_array.push(sum);",
      "                }",
      "            }",
      "            cum_sum.push(sum);",
      "        }",
      "        BIT { internal_array }",
      "    }",
      "    pub fn add(&mut self, mut index: usize, new_value: T) {",
      "        index += 1;",
      "        while index <= self.internal_array.len() {",
      "            self.internal_array[index - 1] += new_value;",
      "            index += index & index.wrapping_neg();",
      "        }",
      "    }",
      "    pub fn query(&self, start_index: usize, end_index: usize) -> T {",
      "        if start_index == 0 {",
      "            self.calc_sum(end_index)",
      "        } else {",
      "            self.calc_sum(end_index) - self.calc_sum(start_index)",
      "        }",
      "    }",
      "    fn calc_sum(&self, mut index: usize) -> T {",
      "        let mut sum = self.internal_array[index - 1];",
      "        index &= index - 1;",
      "        while index > 0 {",
      "            sum += self.internal_array[index - 1];",
      "            index &= index - 1;",
      "        }",
      "        sum",
      "    }",
      "}"
    ]
  },
  "@BinSearchPower": {
    "prefix": "@BinSearchPower",
    "body": [
      "pub trait BinSearchPower<T: std::cmp::PartialOrd> {",
      "    fn lower_bound_only_asc(&self, value: T) -> Option<usize>;",
      "    fn upper_bound_only_asc(&self, value: T) -> Option<usize>;",
      "}",
      "impl<T: std::cmp::PartialOrd> BinSearchPower<T> for [T] {",
      "    fn lower_bound_only_asc(&self, value: T) -> Option<usize> {",
      "        let mut ng = -1;",
      "        let mut ok = self.len() as i64;",
      "        while ok - ng > 1 {",
      "            let mid = (ok + ng) / 2;",
      "            if self[mid as usize] >= value {",
      "                ok = mid;",
      "            } else {",
      "                ng = mid;",
      "            }",
      "        }",
      "        if ok == self.len() as i64 {",
      "            None",
      "        } else {",
      "            Some(ok as usize)",
      "        }",
      "    }",
      "    fn upper_bound_only_asc(&self, value: T) -> Option<usize> {",
      "        let mut ng = -1;",
      "        let mut ok = self.len() as i64;",
      "        while ok - ng > 1 {",
      "            let mid = (ok + ng) / 2;",
      "            if self[mid as usize] > value {",
      "                ok = mid;",
      "            } else {",
      "                ng = mid;",
      "            }",
      "        }",
      "        if ok == self.len() as i64 {",
      "            None",
      "        } else {",
      "            Some(ok as usize)",
      "        }",
      "    }",
      "}"
    ]
  },
  "@LazySegTree": {
    "prefix": "@LazySegTree",
    "body": [
      "pub struct LazySegTree<T: std::clone::Clone + std::fmt::Debug, U: std::clone::Clone> {",
      "    operation: fn(&T, &T) -> T,",
      "    effector: fn(&T, &U) -> T,",
      "    resolve_effect: fn(&U, &U) -> U,",
      "    segment_array: Vec<Option<T>>,",
      "    lazy_array: Vec<Option<U>>,",
      "    origin_length: usize,",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug, U: std::clone::Clone> LazySegTree<T, U> {",
      "    pub fn new(",
      "        array: Vec<T>,",
      "        operation: fn(&T, &T) -> T,",
      "        effector: fn(&T, &U) -> T,",
      "        resolve_effect: fn(&U, &U) -> U,",
      "    ) -> LazySegTree<T, U> {",
      "        let origin_length = array.len();",
      "        let mut all_array_length = 1;",
      "        while origin_length * 2 > all_array_length {",
      "            all_array_length <<= 1;",
      "        }",
      "        let mut segment_array: Vec<Option<T>> = vec![None; all_array_length];",
      "        let lazy_array: Vec<Option<U>> = vec![None; all_array_length];",
      "        let mut target_index = all_array_length >> 1;",
      "        for i in 0..origin_length {",
      "            segment_array[i + target_index] = Some(array[i].clone());",
      "        }",
      "        target_index -= 1;",
      "        while target_index != 0 {",
      "            let left_index = target_index << 1;",
      "            let right_index = (target_index << 1) + 1;",
      "            let value = if let Some(left) = &segment_array[left_index] {",
      "                if let Some(right) = &segment_array[right_index] {",
      "                    Some(operation(&left, &right))",
      "                } else {",
      "                    Some(left.clone())",
      "                }",
      "            } else {",
      "                if let Some(right) = &segment_array[right_index] {",
      "                    Some(right.clone())",
      "                } else {",
      "                    None",
      "                }",
      "            };",
      "            segment_array[target_index] = value;",
      "            target_index -= 1;",
      "        }",
      "        LazySegTree {",
      "            operation,",
      "            effector,",
      "            resolve_effect,",
      "            segment_array,",
      "            lazy_array,",
      "            origin_length: array.len(),",
      "        }",
      "    }",
      "    pub fn query(&mut self, start_index: usize, end_index: usize) -> T {",
      "        if start_index >= end_index {",
      "            panic!();",
      "        }",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let internal_start = origin_start_index + start_index;",
      "        let internal_end = origin_start_index + end_index - 1;",
      "        if internal_end >= origin_start_index + self.origin_length {",
      "            panic!();",
      "        }",
      "        return match self.resolve_effectcalc_section(internal_start, internal_end) {",
      "            Some(x) => x,",
      "            None => panic!(),",
      "        };",
      "    }",
      "    pub fn update(&mut self, index: usize, new_value: T) {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let mut target_index = origin_start_index + index;",
      "        self.segment_array[target_index] = Some(new_value);",
      "        target_index >>= 1;",
      "        while target_index != 0 {",
      "            let new_segment_value = if let Some(left) = &self.segment_array[target_index << 1] {",
      "                if let Some(right) = &self.segment_array[(target_index << 1) + 1] {",
      "                    let operation = self.operation;",
      "                    operation(&left, &right)",
      "                } else {",
      "                    left.clone()",
      "                }",
      "            } else {",
      "                panic!()",
      "            };",
      "            self.segment_array[target_index] = Some(new_segment_value);",
      "            target_index >>= 1;",
      "        }",
      "    }",
      "    pub fn get(&self, index: usize) -> T {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let mut target_index = origin_start_index + index;",
      "        self.segment_array[target_index].clone().unwrap()",
      "    }",
      "    pub fn range_effect(&mut self, start_index: usize, end_index: usize, effect: U) {",
      "        if start_index >= end_index {",
      "            panic!();",
      "        }",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let internal_start = origin_start_index + start_index;",
      "        let internal_end = origin_start_index + end_index - 1;",
      "        if internal_end >= origin_start_index + self.origin_length {",
      "            panic!();",
      "        }",
      "        self.resolve_effectapply_effector(internal_start, internal_end, &effect);",
      "    }",
      "    fn resolve_effectapply_effector(",
      "        &mut self,",
      "        internal_start: usize,",
      "        internal_end: usize,",
      "        effect: &U,",
      "    ) -> () {",
      "        if internal_start == internal_end {",
      "            self.resolve_effectapply_effector_lazy(internal_start, effect);",
      "        } else {",
      "            let section_and = internal_start & internal_end;",
      "            let end_offset = section_and ^ internal_end;",
      "            let xor_digits = 64 - end_offset.leading_zeros();",
      "            if xor_digits == end_offset.count_ones() {",
      "                let section_index = section_and >> xor_digits;",
      "                self.resolve_effectapply_effector_lazy(section_index, effect);",
      "            } else {",
      "                let left_end = section_and + (1 << (xor_digits - 1)) - 1;",
      "                let right_start = left_end + 1;",
      "                self.resolve_effectapply_effector(internal_start, left_end, effect);",
      "                self.resolve_effectapply_effector(right_start, internal_end, effect);",
      "            }",
      "        }",
      "    }",
      "    fn resolve_effectapply_effector_lazy(&mut self, lazy_index: usize, effect: &U) {",
      "        if let Some(x) = &self.lazy_array[lazy_index] {",
      "            let resolve_effect = self.resolve_effect;",
      "            self.lazy_array[lazy_index] = Some(resolve_effect(x, effect));",
      "        } else {",
      "            self.lazy_array[lazy_index] = Some(effect.clone());",
      "        }",
      "    }",
      "    fn resolve_effectcalc_section(",
      "        &mut self,",
      "        internal_start: usize,",
      "        internal_end: usize,",
      "    ) -> Option<T> {",
      "        if internal_start == internal_end {",
      "            return self.resolve_effectget_data(internal_start);",
      "        } else {",
      "            let section_and = internal_start & internal_end;",
      "            let end_offset = section_and ^ internal_end;",
      "            let xor_digits = 64 - end_offset.leading_zeros();",
      "            if xor_digits == end_offset.count_ones() {",
      "                let section_index = section_and >> xor_digits;",
      "                return self.resolve_effectget_data(section_index);",
      "            } else {",
      "                let left_end = section_and + (1 << (xor_digits - 1)) - 1;",
      "                let right_start = left_end + 1;",
      "                let left = self.resolve_effectcalc_section(internal_start, left_end);",
      "                let right = self.resolve_effectcalc_section(right_start, internal_end);",
      "                self.operation(left, right)",
      "            }",
      "        }",
      "    }",
      "    fn resolve_effectget_data(&mut self, internal_index: usize) -> Option<T> {",
      "        if let Some(value) = &self.segment_array[internal_index] {",
      "            let origin_start_index = self.segment_array.len() >> 1;",
      "            if let Some(effect) = &self.lazy_array[internal_index] {",
      "                if internal_index >= origin_start_index {",
      "                    let effector = self.effector;",
      "                    self.segment_array[internal_index] = Some(effector(value, effect));",
      "                } else {",
      "                    let left_index = internal_index << 1;",
      "                    let right_index = (internal_index << 1) + 1;",
      "                    let effect = effect.clone();",
      "                    self.resolve_effectapply_effector_lazy(left_index, &effect);",
      "                    self.resolve_effectapply_effector_lazy(right_index, &effect);",
      "                    let left = self.resolve_effectget_data(left_index);",
      "                    let right = self.resolve_effectget_data(right_index);",
      "                    self.segment_array[internal_index] = self.operation(left, right);",
      "                }",
      "                self.lazy_array[internal_index] = None;",
      "            } else {",
      "                if internal_index >= origin_start_index {",
      "                } else {",
      "                    let left_index = internal_index << 1;",
      "                    let right_index = (internal_index << 1) + 1;",
      "                    let left = self.resolve_effectget_data(left_index);",
      "                    let right = self.resolve_effectget_data(right_index);",
      "                    self.segment_array[internal_index] = self.operation(left, right);",
      "                }",
      "            }",
      "        }",
      "        self.segment_array[internal_index].clone()",
      "    }",
      "    fn operation(&self, left: Option<T>, right: Option<T>) -> Option<T> {",
      "        if let Some(left) = left {",
      "            if let Some(right) = right {",
      "                let operation = self.operation;",
      "                return Some(operation(&left, &right));",
      "            } else {",
      "                return Some(left);",
      "            }",
      "        } else {",
      "            panic!()",
      "        }",
      "    }",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug, U: std::clone::Clone> std::fmt::Debug",
      "    for LazySegTree<T, U>",
      "{",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let target_slice: Vec<_> = self.segment_array[origin_start_index..]",
      "            .iter()",
      "            .filter(|&element| {",
      "                if element.is_some() {",
      "                    return true;",
      "                } else {",
      "                    return false;",
      "                }",
      "            })",
      "            .map(|element| element.as_ref().unwrap().clone())",
      "            .collect();",
      "        f.debug_list().entries(&target_slice).finish()",
      "    }",
      "}"
    ]
  },
  "@SegTree": {
    "prefix": "@SegTree",
    "body": [
      "pub struct SegTree<T: std::clone::Clone + std::fmt::Debug> {",
      "    operation: fn(&T, &T) -> T,",
      "    segment_array: Vec<Option<T>>,",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug> SegTree<T> {",
      "    pub fn new(array: Vec<T>, operation: fn(&T, &T) -> T) -> SegTree<T> {",
      "        let origin_length = array.len();",
      "        let mut all_array_length = 1;",
      "        while origin_length * 2 > all_array_length {",
      "            all_array_length <<= 1;",
      "        }",
      "        let mut segment_array: Vec<Option<T>> = vec![None; all_array_length];",
      "        let mut target_index = all_array_length >> 1;",
      "        for i in 0..origin_length {",
      "            segment_array[i + target_index] = Some(array[i].clone());",
      "        }",
      "        target_index -= 1;",
      "        while target_index != 0 {",
      "            let left_index = target_index << 1;",
      "            let right_index = (target_index << 1) + 1;",
      "            let value = if let Some(left) = &segment_array[left_index] {",
      "                if let Some(right) = &segment_array[right_index] {",
      "                    Some(operation(&left, &right))",
      "                } else {",
      "                    Some(left.clone())",
      "                }",
      "            } else {",
      "                if let Some(right) = &segment_array[right_index] {",
      "                    Some(right.clone())",
      "                } else {",
      "                    None",
      "                }",
      "            };",
      "            segment_array[target_index] = value;",
      "            target_index -= 1;",
      "        }",
      "        SegTree {",
      "            operation,",
      "            segment_array,",
      "        }",
      "    }",
      "    pub fn query(&self, start_index: usize, end_index: usize) -> T {",
      "        if start_index >= end_index {",
      "            panic!();",
      "        }",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let internal_start = origin_start_index + start_index;",
      "        let internal_end = origin_start_index + end_index - 1;",
      "        return match self.calc_section(internal_start, internal_end) {",
      "            Some(x) => x,",
      "            None => panic!(),",
      "        };",
      "    }",
      "    pub fn update(&mut self, index: usize, new_value: T) {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let mut target_index = origin_start_index + index;",
      "        self.segment_array[target_index] = Some(new_value);",
      "        target_index >>= 1;",
      "        while target_index != 0 {",
      "            let new_segment_value = if let Some(left) = &self.segment_array[target_index << 1] {",
      "                if let Some(right) = &self.segment_array[(target_index << 1) + 1] {",
      "                    let operation = self.operation;",
      "                    operation(&left, &right)",
      "                } else {",
      "                    left.clone()",
      "                }",
      "            } else {",
      "                panic!()",
      "            };",
      "            self.segment_array[target_index] = Some(new_segment_value);",
      "            target_index >>= 1;",
      "        }",
      "    }",
      "    pub fn get(&self, index: usize) -> T {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let mut target_index = origin_start_index + index;",
      "        self.segment_array[target_index].clone().unwrap()",
      "    }",
      "    fn calc_section(&self, internal_start: usize, internal_end: usize) -> Option<T> {",
      "        if internal_start == internal_end {",
      "            return self.segment_array[internal_start].clone();",
      "        } else {",
      "            let section_and = internal_start & internal_end;",
      "            let end_offset = section_and ^ internal_end;",
      "            let xor_digits = 64 - end_offset.leading_zeros();",
      "            if xor_digits == end_offset.count_ones() {",
      "                let section_index = section_and >> xor_digits;",
      "                return self.segment_array[section_index].clone();",
      "            } else {",
      "                let left_end = section_and + (1 << (xor_digits - 1)) - 1;",
      "                let right_start = left_end + 1;",
      "                if let Some(left) = self.calc_section(internal_start, left_end) {",
      "                    if let Some(right) = self.calc_section(right_start, internal_end) {",
      "                        let operation = self.operation;",
      "                        return Some(operation(&left, &right));",
      "                    } else {",
      "                        return Some(left);",
      "                    }",
      "                } else {",
      "                    panic!()",
      "                }",
      "            }",
      "        }",
      "    }",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug> std::fmt::Debug for SegTree<T> {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let target_slice: Vec<_> = self.segment_array[origin_start_index..]",
      "            .iter()",
      "            .filter(|&element| {",
      "                if element.is_some() {",
      "                    return true;",
      "                } else {",
      "                    return false;",
      "                }",
      "            })",
      "            .map(|element| element.as_ref().unwrap().clone())",
      "            .collect();",
      "        f.debug_list().entries(&target_slice).finish()",
      "    }",
      "}"
    ]
  },
  "@UnionFind": {
    "prefix": "@UnionFind",
    "body": [
      "struct UnionFind {",
      "    parent: Vec<usize>,",
      "    rank: Vec<usize>,",
      "    size: Vec<usize>,",
      "}",
      "impl UnionFind {",
      "    fn new(n: usize) -> UnionFind {",
      "        UnionFind {",
      "            parent: (0..n).collect(),",
      "            rank: vec![0; n],",
      "            size: vec![1; n],",
      "        }",
      "    }",
      "    fn root(&mut self, x: usize) -> usize {",
      "        let parent = self.parent[x];",
      "        if parent != x {",
      "            self.parent[x] = self.root(parent);",
      "            self.rank[x] = 1;",
      "        }",
      "        return self.parent[x];",
      "    }",
      "    fn unite(&mut self, x: usize, y: usize) {",
      "        if self.same(x, y) {",
      "            return;",
      "        }",
      "        let x_root = self.root(x);",
      "        let y_root = self.root(y);",
      "        if self.rank[x_root] >= self.rank[y_root] {",
      "            self.size[x_root] += self.size(y);",
      "            self.rank[y_root] = 1;",
      "            self.parent[y_root] = x_root;",
      "        } else {",
      "            let x_root = self.root(x);",
      "            let y_root = self.root(y);",
      "            self.size[y_root] += self.size(x);",
      "            self.rank[x_root] = 1;",
      "            self.parent[x_root] = y_root;",
      "        }",
      "    }",
      "    fn size(&mut self, x: usize) -> usize {",
      "        let x_root = self.root(x);",
      "        return self.size[x_root];",
      "    }",
      "    fn same(&mut self, x: usize, y: usize) -> bool {",
      "        self.root(x) == self.root(y)",
      "    }",
      "}"
    ]
  },
  "@ceil": {
    "prefix": "@ceil",
    "body": [
      "fn ceil(top: usize, bottom: usize) -> usize {",
      "    (top + bottom - 1) / bottom",
      "}"
    ]
  },
  "@combination_mod": {
    "prefix": "@combination_mod",
    "body": [
      "fn power_mod(base: usize, exp: usize, modulo: usize) -> usize {",
      "    if exp == 0 {",
      "        return 1;",
      "    } else if exp & 1 == 0 {",
      "        return (power_mod(base, exp / 2, modulo) % modulo).pow(2) % modulo;",
      "    } else {",
      "        return power_mod(base, exp - 1, modulo) % modulo * base % modulo;",
      "    }",
      "}",
      "fn inverse_mod(element: usize, prime_modulo: usize) -> usize {",
      "    power_mod(element, prime_modulo - 2, prime_modulo) % prime_modulo",
      "}",
      "fn permutation_mod(m: usize, n: usize, prime_modulo: usize) -> usize {",
      "    let mut numerator = 1;",
      "    for i in 0..n {",
      "        numerator *= m - i;",
      "        numerator %= prime_modulo;",
      "    }",
      "    numerator",
      "}",
      "fn combination_mod(m: usize, n: usize, prime_modulo: usize) -> usize {",
      "    let permutation = permutation_mod(m, n, prime_modulo);",
      "    let mut element = 1;",
      "    for j in 1..(n + 1) {",
      "        element *= j;",
      "        element %= prime_modulo;",
      "    }",
      "    permutation * inverse_mod(element, prime_modulo) % prime_modulo",
      "}"
    ]
  },
  "@enumerate_divisor": {
    "prefix": "@enumerate_divisor",
    "body": [
      "fn enumerate_divisor(n: usize) -> Vec<usize> {",
      "    let mut i = 1;",
      "    let mut divisors = vec![];",
      "    while i * i <= n {",
      "        if n % i == 0 {",
      "            divisors.push(i);",
      "            if i != n / i {",
      "                divisors.push(n / i);",
      "            }",
      "        }",
      "        i += 1;",
      "    }",
      "    divisors.sort();",
      "    divisors",
      "}"
    ]
  },
  "@eratosthenes": {
    "prefix": "@eratosthenes",
    "body": [
      "fn eratosthenes(n: usize) -> Vec<usize> {",
      "    let mut res = Vec::with_capacity(n - 1);",
      "    for i in 2..=n {",
      "        res.push(i);",
      "    }",
      "    for i in 2..=(n as f64).sqrt() as usize {",
      "        if res[i - 2] < i {",
      "            continue;",
      "        }",
      "        for j in (i * i..=n).step_by(i) {",
      "            if res[j - 2] == j {",
      "                res[j - 2] = i;",
      "            }",
      "        }",
      "    }",
      "    res.sort();",
      "    res.dedup();",
      "    res",
      "}"
    ]
  },
  "@floor_sum": {
    "prefix": "@floor_sum",
    "body": [
      "fn floor_sum(n: i64, m: i64, mut a: i64, mut b: i64) -> i64 {",
      "    let mut ans = 0;",
      "    if a >= m {",
      "        let q_a = a / m;",
      "        ans += n * (n - 1) * q_a / 2;",
      "        a %= m;",
      "    }",
      "    if b >= m {",
      "        let q_b = b / m;",
      "        ans += n * q_b;",
      "        b %= m;",
      "    }",
      "    let y_max = (a * n + b) / m;",
      "    let x_max = y_max * m - b;",
      "    if y_max == 0 {",
      "        return ans;",
      "    }",
      "    ans += (n - (x_max + a - 1) / a) * y_max;",
      "    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);",
      "    ans",
      "}"
    ]
  },
  "@gcd": {
    "prefix": "@gcd",
    "body": [
      "fn gcd(a: usize, b: usize) -> usize {",
      "    let mut aa: usize = if a > b { a } else { b };",
      "    let mut bb: usize = if a > b { b } else { a };",
      "    while bb != 0 {",
      "        let tmp = bb;",
      "        bb = aa % tmp;",
      "        aa = tmp;",
      "    }",
      "    return aa;",
      "}"
    ]
  },
  "@inverse_mod": {
    "prefix": "@inverse_mod",
    "body": [
      "fn power_mod(base: usize, exp: usize, modulo: usize) -> usize {",
      "    if exp == 0 {",
      "        return 1;",
      "    } else if exp & 1 == 0 {",
      "        return (power_mod(base, exp / 2, modulo) % modulo).pow(2) % modulo;",
      "    } else {",
      "        return power_mod(base, exp - 1, modulo) % modulo * base % modulo;",
      "    }",
      "}",
      "fn inverse_mod(element: usize, prime_modulo: usize) -> usize {",
      "    power_mod(element, prime_modulo - 2, prime_modulo) % prime_modulo",
      "}"
    ]
  },
  "@lcm": {
    "prefix": "@lcm",
    "body": [
      "fn gcd(a: usize, b: usize) -> usize {",
      "    let mut aa: usize = if a > b { a } else { b };",
      "    let mut bb: usize = if a > b { b } else { a };",
      "    while bb != 0 {",
      "        let tmp = bb;",
      "        bb = aa % tmp;",
      "        aa = tmp;",
      "    }",
      "    return aa;",
      "}",
      "fn lcm(a: usize, b: usize) -> usize {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  },
  "@next_permutation": {
    "prefix": "@next_permutation",
    "body": [
      "fn next_permutation<T: std::cmp::PartialOrd>(array: &mut [T]) -> Option<usize> {",
      "    let n = array.len();",
      "    if n < 2 {",
      "        return None;",
      "    }",
      "    let mut desc_begin_index = n - 1;",
      "    for i in (0..n - 1).rev() {",
      "        if array[i] <= array[i + 1] {",
      "            break;",
      "        }",
      "        desc_begin_index = i;",
      "    }",
      "    if desc_begin_index == 0 {",
      "        array.reverse();",
      "        return None;",
      "    }",
      "    desc_begin_index -= 1;",
      "    let pivot = &array[desc_begin_index];",
      "    let mut swap_to = n;",
      "    for i in (desc_begin_index..n).rev() {",
      "        if array[i] > *pivot {",
      "            swap_to = i;",
      "            break;",
      "        }",
      "    }",
      "    array.swap(desc_begin_index, swap_to);",
      "    array[desc_begin_index + 1..n].reverse();",
      "    Some(desc_begin_index)",
      "}"
    ]
  },
  "@power_mod": {
    "prefix": "@power_mod",
    "body": [
      "fn power_mod(base: usize, exp: usize, modulo: usize) -> usize {",
      "    if exp == 0 {",
      "        return 1;",
      "    } else if exp & 1 == 0 {",
      "        return (power_mod(base, exp / 2, modulo) % modulo).pow(2) % modulo;",
      "    } else {",
      "        return power_mod(base, exp - 1, modulo) % modulo * base % modulo;",
      "    }",
      "}"
    ]
  },
  "@prev_permutation": {
    "prefix": "@prev_permutation",
    "body": [
      "fn prev_permutation<T: std::cmp::PartialOrd>(array: &mut [T]) -> Option<usize> {",
      "    let n = array.len();",
      "    if n < 2 {",
      "        return None;",
      "    }",
      "    let mut asc_begin_index = n - 1;",
      "    for i in (0..n - 1).rev() {",
      "        if array[i] >= array[i + 1] {",
      "            break;",
      "        }",
      "        asc_begin_index = i;",
      "    }",
      "    if asc_begin_index == 0 {",
      "        array.reverse();",
      "        return None;",
      "    }",
      "    asc_begin_index -= 1;",
      "    let pivot = &array[asc_begin_index];",
      "    let mut swap_to = n;",
      "    for i in (asc_begin_index..n).rev() {",
      "        if array[i] < *pivot {",
      "            swap_to = i;",
      "            break;",
      "        }",
      "    }",
      "    array.swap(asc_begin_index, swap_to);",
      "    array[asc_begin_index + 1..n].reverse();",
      "    Some(asc_begin_index)",
      "}"
    ]
  },
  "@suffix_array": {
    "prefix": "@suffix_array",
    "body": [
      "pub fn suffix_array(s: &[char]) -> Vec<usize> {",
      "    let mut max_s_i = 0;",
      "    let s_i: Vec<usize> = s",
      "        .iter()",
      "        .map(|&c| {",
      "            let i = c as usize;",
      "            max_s_i = std::cmp::max(max_s_i, i);",
      "            i",
      "        })",
      "        .collect();",
      "    sa_is(&s_i, max_s_i)",
      "}",
      "fn sa_is(s_i: &[usize], max_s_i: usize) -> Vec<usize> {",
      "    let n = s_i.len();",
      "    match n {",
      "        0 => return vec![],",
      "        1 => return vec![0],",
      "        2 => {",
      "            return if s_i[0] < s_i[1] {",
      "                vec![0, 1]",
      "            } else {",
      "                vec![1, 0]",
      "            }",
      "        }",
      "        _ => (),",
      "    }",
      "    let mut is_L = vec![true; n];",
      "    for i in (0..n - 1).rev() {",
      "        is_L[i] = if s_i[i] == s_i[i + 1] {",
      "            is_L[i + 1]",
      "        } else {",
      "            s_i[i] >= s_i[i + 1]",
      "        };",
      "    }",
      "    let mut char_L_count = vec![0; max_s_i + 1];",
      "    let mut char_S_count = vec![0; max_s_i + 1];",
      "    for i in 0..n {",
      "        if is_L[i] {",
      "            char_L_count[s_i[i]] += 1;",
      "        } else {",
      "            char_S_count[s_i[i]] += 1;",
      "        }",
      "    }",
      "    let mut char_ranges = vec![(0, 0); max_s_i + 1];",
      "    let mut last = 0;",
      "    for c in 0..=max_s_i {",
      "        let c_total = char_L_count[c] + char_S_count[c];",
      "        if c_total != 0 {",
      "            char_ranges[c] = (last, last + c_total);",
      "            last += c_total;",
      "        }",
      "    }",
      "    let mut lms_index = vec![0; n];",
      "    let mut lms_count = 0;",
      "    for i in 1..n {",
      "        if is_L[i - 1] && !is_L[i] {",
      "            lms_count += 1;",
      "            lms_index[i] = lms_count;",
      "        }",
      "    }",
      "    let mut lms = Vec::with_capacity(lms_count);",
      "    for i in 1..n {",
      "        if lms_index[i] != 0 {",
      "            lms.push(i);",
      "        }",
      "    }",
      "    let mut sa = vec![0; n];",
      "    induced_sort(&mut sa, &s_i, &lms, &char_L_count, &char_ranges);",
      "    if lms_count > 0 {",
      "        let mut sorted_lms = Vec::with_capacity(lms_count);",
      "        for &i in &sa {",
      "            if lms_index[i - 1] != 0 {",
      "                sorted_lms.push(i - 1);",
      "            }",
      "        }",
      "        let mut lms_part_nums = vec![0; lms_count];",
      "        let mut max_lms_part_index = 0;",
      "        for i in 1..lms_count {",
      "            let lms1_start = sorted_lms[i - 1];",
      "            let lms1_end = if lms_index[lms1_start] == lms_count {",
      "                n",
      "            } else {",
      "                lms[lms_index[lms1_start]]",
      "            };",
      "            let lms2_start = sorted_lms[i];",
      "            let lms2_end = if lms_index[lms2_start] == lms_count {",
      "                n",
      "            } else {",
      "                lms[lms_index[lms2_start]]",
      "            };",
      "            let same = if (lms1_end - lms1_start) != (lms2_end - lms2_start) {",
      "                false",
      "            } else {",
      "                let mut same_all = true;",
      "                for o in 0..(lms1_end - lms1_start) {",
      "                    same_all = s_i[lms1_start + o] == s_i[lms2_start + o];",
      "                    if !same_all {",
      "                        break;",
      "                    }",
      "                }",
      "                same_all",
      "            };",
      "            if !same {",
      "                max_lms_part_index += 1;",
      "            }",
      "            lms_part_nums[lms_index[sorted_lms[i]] - 1] = max_lms_part_index;",
      "        }",
      "        let lms_part_sa = sa_is(&lms_part_nums, max_lms_part_index);",
      "        for i in 0..lms_count {",
      "            sorted_lms[i] = lms[lms_part_sa[i]];",
      "        }",
      "        induced_sort(&mut sa, &s_i, &sorted_lms, &char_L_count, &char_ranges);",
      "    }",
      "    sa.iter().map(|index1| index1 - 1).collect()",
      "}",
      "fn induced_sort(",
      "    sa: &mut [usize],",
      "    s_i: &[usize],",
      "    lms: &[usize],",
      "    char_L_count: &[usize],",
      "    char_ranges: &[(usize, usize)],",
      ") {",
      "    let n = s_i.len();",
      "    for i in sa.iter_mut() {",
      "        *i = 0;",
      "    }",
      "    let mut index_to_info = vec![(0, true); n];",
      "    let mut checked = vec![false; char_L_count.len()];",
      "    for i in 0..n {",
      "        let c = s_i[i];",
      "        let c_range = char_ranges[c];",
      "        let mut l_count = char_L_count[c];",
      "        if !checked[c] {",
      "            for j in c_range.0..c_range.1 {",
      "                let is_L = if l_count != 0 { true } else { false };",
      "                if l_count != 0 {",
      "                    l_count -= 1;",
      "                };",
      "                index_to_info[j] = (c, is_L);",
      "            }",
      "            checked[c] = true;",
      "        }",
      "    }",
      "    let mut now_char_index = vec![std::usize::MAX; char_L_count.len()];",
      "    for &i in lms.iter().rev() {",
      "        let c = s_i[i];",
      "        now_char_index[c] = if now_char_index[c] == std::usize::MAX {",
      "            char_ranges[c].1",
      "        } else {",
      "            now_char_index[c]",
      "        } - 1;",
      "        sa[now_char_index[c]] = i + 1;",
      "    }",
      "    let mut char_insert_count = vec![0; char_L_count.len()];",
      "    let c = s_i[n - 1];",
      "    sa[char_ranges[c].0 + char_insert_count[c]] = n;",
      "    char_insert_count[c] += 1;",
      "    for i in 0..n {",
      "        if sa[i] < 2 {",
      "            continue;",
      "        }",
      "        let target_index = sa[i] - 2;",
      "        let target_c = s_i[target_index];",
      "        let target_start_index = char_ranges[target_c].0;",
      "        let to_index = target_start_index + char_insert_count[target_c];",
      "        let to_is_L = index_to_info[to_index].1;",
      "        if to_is_L {",
      "            sa[to_index] = target_index + 1;",
      "            char_insert_count[target_c] += 1;",
      "        }",
      "    }",
      "    char_insert_count = vec![0; char_L_count.len()];",
      "    for i in (0..n).rev() {",
      "        if sa[i] < 2 {",
      "            continue;",
      "        }",
      "        let target_index = sa[i] - 2;",
      "        let target_c = s_i[target_index];",
      "        let target_end_index = char_ranges[target_c].1 - 1;",
      "        let to_index = target_end_index - char_insert_count[target_c];",
      "        let to_is_S = !index_to_info[to_index].1;",
      "        if to_is_S {",
      "            sa[to_index] = target_index + 1;",
      "            char_insert_count[target_c] += 1;",
      "        }",
      "    }",
      "}"
    ]
  },
  "@topological_sort_directed": {
    "prefix": "@topological_sort_directed",
    "body": [
      "fn topological_sort_directed_graph(n: usize, zeroIndexedEdges: &[(usize, usize)]) -> Vec<usize> {",
      "    let mut result = vec![];",
      "    let mut isolated = VecDeque::new();",
      "    let mut to = vec![vec![]; n];",
      "    let mut deg = vec![0; n + 1];",
      "    for e in zeroIndexedEdges {",
      "        to[e.0].push(e.1);",
      "        deg[e.1] += 1;",
      "    }",
      "    for i in 0..n {",
      "        if deg[i] == 0 {",
      "            isolated.push_front(i);",
      "        }",
      "    }",
      "    while isolated.len() != 0 {",
      "        let next = isolated.pop_back().unwrap();",
      "        result.push(next);",
      "        for i in &to[next] {",
      "            deg[*i] -= 1;",
      "            if deg[*i] == 0 {",
      "                isolated.push_front(*i);",
      "            }",
      "        }",
      "    }",
      "    result",
      "}"
    ]
  },
  "@topological_sort_undirected": {
    "prefix": "@topological_sort_undirected",
    "body": [
      "fn topological_sort_undirected_graph(n: usize, zeroIndexedEdges: &[(usize, usize)]) -> Vec<usize> {",
      "    let mut result = vec![];",
      "    let mut isolated = VecDeque::new();",
      "    let mut to = vec![vec![]; n];",
      "    let mut deg = vec![0; n + 1];",
      "    for e in zeroIndexedEdges {",
      "        to[e.0].push(e.1);",
      "        to[e.1].push(e.0);",
      "        deg[e.1] += 1;",
      "    }",
      "    for i in 0..n {",
      "        if deg[i] == 0 {",
      "            isolated.push_front(i);",
      "        }",
      "    }",
      "    while isolated.len() != 0 {",
      "        let next = isolated.pop_back().unwrap();",
      "        result.push(next);",
      "        for i in &to[next] {",
      "            deg[*i] -= 1;",
      "            if deg[*i] == 1 {",
      "                isolated.push_front(*i);",
      "            }",
      "        }",
      "    }",
      "    result",
      "}"
    ]
  },
  "@z_algorithm": {
    "prefix": "@z_algorithm",
    "body": [
      "pub fn z_algorithm(s: &[char]) -> Vec<usize> {",
      "    let mut z = vec![0; s.len()];",
      "    z[0] = s.len();",
      "    let mut i = 1;",
      "    let mut j = 0;",
      "    while i < s.len() {",
      "        while i + j < s.len() && s[j] == s[i + j] {",
      "            j += 1;",
      "        }",
      "        z[i] = j;",
      "        if j == 0 {",
      "            i += 1;",
      "            continue;",
      "        }",
      "        let mut k = 1;",
      "        while k < j && k + z[k] < j {",
      "            z[i + k] = z[k];",
      "            k += 1;",
      "        }",
      "        i += k;",
      "        j -= k;",
      "    }",
      "    z",
      "}"
    ]
  }
}
