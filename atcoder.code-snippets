{
  "@BIT": {
    "prefix": "@BIT",
    "body": [
      "pub struct BIT<",
      "    T: std::ops::AddAssign + std::ops::Sub<Output = T> + std::marker::Copy + std::fmt::Debug,",
      "> {",
      "    internal_array: Vec<T>,",
      "}",
      "impl<T: std::ops::AddAssign + std::ops::Sub<Output = T> + std::marker::Copy + std::fmt::Debug>",
      "    BIT<T>",
      "{",
      "    pub fn new(array: Vec<T>) -> BIT<T> {",
      "        let mut internal_array: Vec<T> = Vec::with_capacity(array.len());",
      "        if array.len() == 0 {",
      "            return BIT { internal_array };",
      "        }",
      "        let mut cum_sum: Vec<T> = Vec::with_capacity(array.len());",
      "        internal_array.push(array[0]);",
      "        cum_sum.push(array[0]);",
      "        let mut sum = array[0];",
      "        for i in 1..array.len() {",
      "            let mut lsb = 0;",
      "            let mut tmp_i = i + 1;",
      "            let mut now_digit = 1;",
      "            while lsb == 0 {",
      "                if tmp_i & 1 == 1 {",
      "                    lsb = now_digit;",
      "                } else {",
      "                    tmp_i >>= 1;",
      "                    now_digit += 1;",
      "                }",
      "            }",
      "            sum += array[i];",
      "            if lsb == 1 {",
      "                internal_array.push(array[i]);",
      "            } else {",
      "                if (1 << lsb) < i {",
      "                    internal_array.push(sum - cum_sum[i - (1 << (lsb - 1))]);",
      "                } else {",
      "                    internal_array.push(sum);",
      "                }",
      "            }",
      "            cum_sum.push(sum);",
      "        }",
      "        BIT { internal_array }",
      "    }",
      "    pub fn add(&mut self, mut index: usize, new_value: T) {",
      "        index += 1;",
      "        while index <= self.internal_array.len() {",
      "            self.internal_array[index - 1] += new_value;",
      "            index += index & index.wrapping_neg();",
      "        }",
      "    }",
      "    pub fn query(&self, start_index: usize, end_index: usize) -> T {",
      "        if start_index == 0 {",
      "            self.calc_sum(end_index)",
      "        } else {",
      "            self.calc_sum(end_index) - self.calc_sum(start_index)",
      "        }",
      "    }",
      "    fn calc_sum(&self, mut index: usize) -> T {",
      "        let mut sum = self.internal_array[index - 1];",
      "        index &= index - 1;",
      "        while index > 0 {",
      "            sum += self.internal_array[index - 1];",
      "            index &= index - 1;",
      "        }",
      "        sum",
      "    }",
      "}"
    ]
  },
  "@BinSearchPower": {
    "prefix": "@BinSearchPower",
    "body": [
      "pub trait BinSearchPower<T: std::cmp::PartialOrd> {",
      "    fn lower_bound_only_asc(&self, value: T) -> Option<usize>;",
      "    fn upper_bound_only_asc(&self, value: T) -> Option<usize>;",
      "}",
      "impl<T: std::cmp::PartialOrd> BinSearchPower<T> for [T] {",
      "    fn lower_bound_only_asc(&self, value: T) -> Option<usize> {",
      "        let mut ng = -1;",
      "        let mut ok = self.len() as i64;",
      "        while ok - ng > 1 {",
      "            let mid = (ok + ng) / 2;",
      "            if self[mid as usize] >= value {",
      "                ok = mid;",
      "            } else {",
      "                ng = mid;",
      "            }",
      "        }",
      "        if ok == self.len() as i64 {",
      "            None",
      "        } else {",
      "            Some(ok as usize)",
      "        }",
      "    }",
      "    fn upper_bound_only_asc(&self, value: T) -> Option<usize> {",
      "        let mut ng = -1;",
      "        let mut ok = self.len() as i64;",
      "        while ok - ng > 1 {",
      "            let mid = (ok + ng) / 2;",
      "            if self[mid as usize] > value {",
      "                ok = mid;",
      "            } else {",
      "                ng = mid;",
      "            }",
      "        }",
      "        if ok == self.len() as i64 {",
      "            None",
      "        } else {",
      "            Some(ok as usize)",
      "        }",
      "    }",
      "}"
    ]
  },
  "@LazySegTree": {
    "prefix": "@LazySegTree",
    "body": [
      "pub struct LazySegTree<",
      "    T: std::clone::Clone + std::fmt::Debug,",
      "    U: std::clone::Clone + std::fmt::Debug,",
      "> {",
      "    operation: fn(T, T) -> T,",
      "    effector: fn(T, U) -> T,",
      "    resolve_effect: fn(U, U) -> U,",
      "    segment_array: Vec<Option<T>>,",
      "    lazy_array: Vec<Option<U>>,",
      "    origin_length: usize,",
      "    origin_power: usize,",
      "    log: usize,",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug, U: std::clone::Clone + std::fmt::Debug>",
      "    LazySegTree<T, U>",
      "{",
      "    pub fn new(",
      "        array: Vec<T>,",
      "        operation: fn(T, T) -> T,",
      "        effector: fn(T, U) -> T,",
      "        resolve_effect: fn(U, U) -> U,",
      "    ) -> LazySegTree<T, U> {",
      "        let origin_length = array.len();",
      "        let mut power = 1;",
      "        let mut log = 0;",
      "        while origin_length > power {",
      "            power <<= 1;",
      "            log += 1;",
      "        }",
      "        let mut segment_array: Vec<Option<T>> = vec![None; 2 * power];",
      "        let lazy_array: Vec<Option<U>> = vec![None; power];",
      "        for i in power..(power + origin_length) {",
      "            segment_array[i] = Some(array[i - power].clone());",
      "        }",
      "        let mut lazy_seg_tree = LazySegTree {",
      "            operation,",
      "            effector,",
      "            resolve_effect,",
      "            segment_array,",
      "            lazy_array,",
      "            origin_length,",
      "            origin_power: power,",
      "            log,",
      "        };",
      "        for i in (1..power).rev() {",
      "            lazy_seg_tree.update(i);",
      "        }",
      "        lazy_seg_tree",
      "    }",
      "    pub fn query(&mut self, mut left_index: usize, mut right_index: usize) -> T {",
      "        assert!(left_index < right_index && right_index <= self.origin_power);",
      "        left_index += self.origin_power;",
      "        right_index += self.origin_power;",
      "        for i in (1..=self.log).rev() {",
      "            if ((left_index >> i) << i) != left_index {",
      "                self.push(left_index >> i);",
      "            }",
      "            if ((right_index >> i) << i) != right_index {",
      "                self.push(right_index >> i);",
      "            }",
      "        }",
      "        let operation = self.operation;",
      "        let mut left_value = None;",
      "        let mut right_value = None;",
      "        while left_index < right_index {",
      "            if left_index & 1 != 0 {",
      "                left_value = if left_value.is_some() && self.segment_array[left_index].is_some() {",
      "                    let operation = self.operation;",
      "                    Some(operation(",
      "                        left_value.unwrap(),",
      "                        self.segment_array[left_index].clone().unwrap(),",
      "                    ))",
      "                } else if self.segment_array[left_index].is_some() {",
      "                    Some(self.segment_array[left_index].clone().unwrap())",
      "                } else {",
      "                    left_value",
      "                };",
      "                left_index += 1;",
      "            }",
      "            if right_index & 1 != 0 {",
      "                right_index -= 1;",
      "                right_value = if right_value.is_some() && self.segment_array[right_index].is_some()",
      "                {",
      "                    Some(operation(",
      "                        self.segment_array[right_index].clone().unwrap(),",
      "                        right_value.unwrap(),",
      "                    ))",
      "                } else if self.segment_array[right_index].is_some() {",
      "                    Some(self.segment_array[right_index].clone().unwrap())",
      "                } else {",
      "                    right_value",
      "                };",
      "            }",
      "            left_index >>= 1;",
      "            right_index >>= 1;",
      "        }",
      "        if left_value.is_some() && right_value.is_some() {",
      "            operation(left_value.clone().unwrap(), right_value.clone().unwrap())",
      "        } else if left_value.is_some() {",
      "            left_value.clone().unwrap()",
      "        } else if right_value.is_some() {",
      "            right_value.clone().unwrap()",
      "        } else {",
      "            panic!()",
      "        }",
      "    }",
      "    fn update(&mut self, index: usize) {",
      "        let operation = self.operation;",
      "        let a = self.segment_array[2 * index].clone();",
      "        let b = self.segment_array[2 * index + 1].clone();",
      "        let value = if a.is_some() && b.is_some() {",
      "            Some(operation(a.unwrap(), b.unwrap()))",
      "        } else if a.is_some() {",
      "            Some(a.unwrap())",
      "        } else if b.is_some() {",
      "            Some(b.unwrap())",
      "        } else {",
      "            None",
      "        };",
      "        self.segment_array[index] = value;",
      "    }",
      "    pub fn get(&mut self, mut index: usize) -> T {",
      "        assert!(index < self.origin_length);",
      "        index += self.origin_power;",
      "        for i in (1..=self.log).rev() {",
      "            self.push(index >> i);",
      "        }",
      "        self.segment_array[index].clone().unwrap()",
      "    }",
      "    pub fn set(&mut self, mut index: usize, new_value: T) {",
      "        assert!(index < self.origin_length);",
      "        index += self.origin_power;",
      "        for i in (1..=self.log).rev() {",
      "            self.push(index >> i);",
      "        }",
      "        self.segment_array[index] = Some(new_value);",
      "        for i in 1..=self.log {",
      "            self.update(index >> i);",
      "        }",
      "    }",
      "    fn push(&mut self, index: usize) {",
      "        if self.lazy_array[index].is_some() {",
      "            let effect = self.lazy_array[index].clone().unwrap();",
      "            self.all_apply(2 * index, effect.clone());",
      "            self.all_apply(2 * index + 1, effect);",
      "        }",
      "        self.lazy_array[index] = None;",
      "    }",
      "    fn all_apply(&mut self, seg_index: usize, effect: U) {",
      "        if self.segment_array[seg_index].is_some() {",
      "            let value = self.segment_array[seg_index].clone().unwrap();",
      "            let effector = self.effector;",
      "            self.segment_array[seg_index] = Some(effector(value, effect.clone()));",
      "        }",
      "        if seg_index < self.origin_power {",
      "            if self.lazy_array[seg_index].is_some() {",
      "                let origin_effect = self.lazy_array[seg_index].clone().unwrap();",
      "                let resolve_effect = self.resolve_effect;",
      "                self.lazy_array[seg_index] = Some(resolve_effect(origin_effect, effect.clone()));",
      "            } else {",
      "                self.lazy_array[seg_index] = Some(effect.clone());",
      "            }",
      "        }",
      "    }",
      "    pub fn apply(&mut self, mut index: usize, effect: U) {",
      "        assert!(index < self.origin_length);",
      "        index += self.origin_power;",
      "        for i in (1..=self.log).rev() {",
      "            self.push(index >> i);",
      "        }",
      "        if self.segment_array[index].is_some() {",
      "            let effector = self.effector;",
      "            self.segment_array[index] =",
      "                Some(effector(self.segment_array[index].clone().unwrap(), effect));",
      "        }",
      "        for i in 1..=self.log {",
      "            self.update(index >> i);",
      "        }",
      "    }",
      "    pub fn apply_range(&mut self, mut left_index: usize, mut right_index: usize, effect: U) {",
      "        assert!(left_index < right_index && right_index <= self.origin_power);",
      "        left_index += self.origin_power;",
      "        right_index += self.origin_power;",
      "        for i in (1..=self.log).rev() {",
      "            if ((left_index >> i) << i) != left_index {",
      "                self.push(left_index >> i);",
      "            }",
      "            if ((right_index >> i) << i) != right_index {",
      "                self.push((right_index - 1) >> i);",
      "            }",
      "        }",
      "        {",
      "            let left_index_tmp = left_index;",
      "            let right_index_tmp = right_index;",
      "            while left_index < right_index {",
      "                if left_index & 1 != 0 {",
      "                    self.all_apply(left_index, effect.clone());",
      "                    left_index += 1;",
      "                }",
      "                if right_index & 1 != 0 {",
      "                    right_index -= 1;",
      "                    self.all_apply(right_index, effect.clone());",
      "                }",
      "                left_index >>= 1;",
      "                right_index >>= 1;",
      "            }",
      "            left_index = left_index_tmp;",
      "            right_index = right_index_tmp;",
      "        }",
      "        for i in 1..=self.log {",
      "            if ((left_index >> i) << i) != left_index {",
      "                self.update(left_index >> i);",
      "            }",
      "            if ((right_index >> i) << i) != right_index {",
      "                self.update((right_index - 1) >> i);",
      "            }",
      "        }",
      "    }",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug, U: std::clone::Clone + std::fmt::Debug> std::fmt::Debug",
      "    for LazySegTree<T, U>",
      "{",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let target_slice: Vec<_> = self.segment_array[origin_start_index..]",
      "            .iter()",
      "            .filter(|&element| {",
      "                if element.is_some() {",
      "                    return true;",
      "                } else {",
      "                    return false;",
      "                }",
      "            })",
      "            .map(|element| element.as_ref().unwrap().clone())",
      "            .collect();",
      "        f.debug_list().entries(&target_slice).finish()",
      "    }",
      "}"
    ]
  },
  "@SegTree": {
    "prefix": "@SegTree",
    "body": [
      "pub struct SegTree<T: std::clone::Clone + std::fmt::Debug> {",
      "    operation: fn(T, T) -> T,",
      "    segment_array: Vec<Option<T>>,",
      "    origin_length: usize,",
      "    origin_power: usize,",
      "    log: usize,",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug> SegTree<T> {",
      "    pub fn new(array: Vec<T>, operation: fn(T, T) -> T) -> SegTree<T> {",
      "        let origin_length = array.len();",
      "        let mut power = 1;",
      "        let mut log = 0;",
      "        while origin_length > power {",
      "            power <<= 1;",
      "            log += 1;",
      "        }",
      "        let mut segment_array: Vec<Option<T>> = vec![None; 2 * power];",
      "        for i in power..(power + origin_length) {",
      "            segment_array[i] = Some(array[i - power].clone());",
      "        }",
      "        let mut seg_tree = SegTree {",
      "            operation,",
      "            segment_array,",
      "            origin_length,",
      "            origin_power: power,",
      "            log,",
      "        };",
      "        for i in (1..power).rev() {",
      "            seg_tree.update(i);",
      "        }",
      "        seg_tree",
      "    }",
      "    pub fn query(&mut self, mut left_index: usize, mut right_index: usize) -> T {",
      "        assert!(left_index < right_index && right_index <= self.origin_power);",
      "        left_index += self.origin_power;",
      "        right_index += self.origin_power;",
      "        let operation = self.operation;",
      "        let mut left_value = None;",
      "        let mut right_value = None;",
      "        while left_index < right_index {",
      "            if left_index & 1 != 0 {",
      "                left_value = if left_value.is_some() && self.segment_array[left_index].is_some() {",
      "                    let operation = self.operation;",
      "                    Some(operation(",
      "                        left_value.unwrap(),",
      "                        self.segment_array[left_index].clone().unwrap(),",
      "                    ))",
      "                } else if self.segment_array[left_index].is_some() {",
      "                    Some(self.segment_array[left_index].clone().unwrap())",
      "                } else {",
      "                    left_value",
      "                };",
      "                left_index += 1;",
      "            }",
      "            if right_index & 1 != 0 {",
      "                right_index -= 1;",
      "                right_value = if right_value.is_some() && self.segment_array[right_index].is_some()",
      "                {",
      "                    Some(operation(",
      "                        self.segment_array[right_index].clone().unwrap(),",
      "                        right_value.unwrap(),",
      "                    ))",
      "                } else if self.segment_array[right_index].is_some() {",
      "                    Some(self.segment_array[right_index].clone().unwrap())",
      "                } else {",
      "                    right_value",
      "                };",
      "            }",
      "            left_index >>= 1;",
      "            right_index >>= 1;",
      "        }",
      "        if left_value.is_some() && right_value.is_some() {",
      "            operation(left_value.clone().unwrap(), right_value.clone().unwrap())",
      "        } else if left_value.is_some() {",
      "            left_value.clone().unwrap()",
      "        } else if right_value.is_some() {",
      "            right_value.clone().unwrap()",
      "        } else {",
      "            panic!()",
      "        }",
      "    }",
      "    fn update(&mut self, index: usize) {",
      "        let operation = self.operation;",
      "        let a = self.segment_array[2 * index].clone();",
      "        let b = self.segment_array[2 * index + 1].clone();",
      "        let value = if a.is_some() && b.is_some() {",
      "            Some(operation(a.unwrap(), b.unwrap()))",
      "        } else if a.is_some() {",
      "            Some(a.unwrap())",
      "        } else if b.is_some() {",
      "            Some(b.unwrap())",
      "        } else {",
      "            None",
      "        };",
      "        self.segment_array[index] = value;",
      "    }",
      "    pub fn get(&mut self, mut index: usize) -> T {",
      "        assert!(index < self.origin_length);",
      "        index += self.origin_power;",
      "        self.segment_array[index].clone().unwrap()",
      "    }",
      "    pub fn set(&mut self, mut index: usize, new_value: T) {",
      "        assert!(index < self.origin_length);",
      "        index += self.origin_power;",
      "        self.segment_array[index] = Some(new_value);",
      "        for i in 1..=self.log {",
      "            self.update(index >> i);",
      "        }",
      "    }",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug> std::fmt::Debug for SegTree<T> {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let target_slice: Vec<_> = self.segment_array[origin_start_index..]",
      "            .iter()",
      "            .filter(|&element| {",
      "                if element.is_some() {",
      "                    return true;",
      "                } else {",
      "                    return false;",
      "                }",
      "            })",
      "            .map(|element| element.as_ref().unwrap().clone())",
      "            .collect();",
      "        f.debug_list().entries(&target_slice).finish()",
      "    }",
      "}"
    ]
  },
  "@UnionFind": {
    "prefix": "@UnionFind",
    "body": [
      "struct UnionFind {",
      "    parent: Vec<usize>,",
      "    rank: Vec<usize>,",
      "    size: Vec<usize>,",
      "}",
      "impl UnionFind {",
      "    fn new(n: usize) -> UnionFind {",
      "        UnionFind {",
      "            parent: (0..n).collect(),",
      "            rank: vec![0; n],",
      "            size: vec![1; n],",
      "        }",
      "    }",
      "    fn root(&mut self, x: usize) -> usize {",
      "        let parent = self.parent[x];",
      "        if parent != x {",
      "            self.parent[x] = self.root(parent);",
      "            self.rank[x] = 1;",
      "        }",
      "        return self.parent[x];",
      "    }",
      "    fn unite(&mut self, x: usize, y: usize) {",
      "        if self.same(x, y) {",
      "            return;",
      "        }",
      "        let x_root = self.root(x);",
      "        let y_root = self.root(y);",
      "        if self.rank[x_root] >= self.rank[y_root] {",
      "            self.size[x_root] += self.size(y);",
      "            self.rank[y_root] = 1;",
      "            self.parent[y_root] = x_root;",
      "        } else {",
      "            let x_root = self.root(x);",
      "            let y_root = self.root(y);",
      "            self.size[y_root] += self.size(x);",
      "            self.rank[x_root] = 1;",
      "            self.parent[x_root] = y_root;",
      "        }",
      "    }",
      "    fn size(&mut self, x: usize) -> usize {",
      "        let x_root = self.root(x);",
      "        return self.size[x_root];",
      "    }",
      "    fn same(&mut self, x: usize, y: usize) -> bool {",
      "        self.root(x) == self.root(y)",
      "    }",
      "}"
    ]
  },
  "@ceil": {
    "prefix": "@ceil",
    "body": [
      "fn ceil(top: usize, bottom: usize) -> usize {",
      "    (top + bottom - 1) / bottom",
      "}"
    ]
  },
  "@enumerate_divisor": {
    "prefix": "@enumerate_divisor",
    "body": [
      "fn enumerate_divisor(n: usize) -> Vec<usize> {",
      "    let mut i = 1;",
      "    let mut divisors = vec![];",
      "    while i * i <= n {",
      "        if n % i == 0 {",
      "            divisors.push(i);",
      "            if i != n / i {",
      "                divisors.push(n / i);",
      "            }",
      "        }",
      "        i += 1;",
      "    }",
      "    divisors.sort();",
      "    divisors",
      "}"
    ]
  },
  "@eratosthenes": {
    "prefix": "@eratosthenes",
    "body": [
      "fn eratosthenes(n: usize) -> Vec<usize> {",
      "    let mut sieve = Vec::with_capacity(n - 1);",
      "    for i in 2..=n {",
      "        sieve.push(i);",
      "    }",
      "    for i in 2..=(n as f64).sqrt() as usize {",
      "        if sieve[i - 2] < i {",
      "            continue;",
      "        }",
      "        for j in (i * i..=n).step_by(i) {",
      "            if sieve[j - 2] == j {",
      "                sieve[j - 2] = i;",
      "            }",
      "        }",
      "    }",
      "    let mut result = Vec::with_capacity(n - 1);",
      "    for i in 2..=n {",
      "        if sieve[i - 2] == i {",
      "            result.push(i);",
      "        }",
      "    }",
      "    result",
      "}"
    ]
  },
  "@extgcd": {
    "prefix": "@extgcd",
    "body": [
      "pub fn extgcd(a: i64, b: i64) -> (i64, i64) {",
      "    if b == 0 {",
      "        return (1, 0);",
      "    }",
      "    let d = extgcd(b, a % b);",
      "    return (d.1, d.0 - a / b * d.1);",
      "}"
    ]
  },
  "@floor_sum": {
    "prefix": "@floor_sum",
    "body": [
      "fn floor_sum(n: i64, m: i64, mut a: i64, mut b: i64) -> i64 {",
      "    let mut ans = 0;",
      "    if a >= m {",
      "        let q_a = a / m;",
      "        ans += n * (n - 1) * q_a / 2;",
      "        a %= m;",
      "    }",
      "    if b >= m {",
      "        let q_b = b / m;",
      "        ans += n * q_b;",
      "        b %= m;",
      "    }",
      "    let y_max = (a * n + b) / m;",
      "    let x_max = y_max * m - b;",
      "    if y_max == 0 {",
      "        return ans;",
      "    }",
      "    ans += (n - (x_max + a - 1) / a) * y_max;",
      "    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);",
      "    ans",
      "}"
    ]
  },
  "@gcd": {
    "prefix": "@gcd",
    "body": [
      "pub fn gcd(a: usize, b: usize) -> usize {",
      "    let mut aa: usize = if a > b { a } else { b };",
      "    let mut bb: usize = if a > b { b } else { a };",
      "    while bb != 0 {",
      "        let tmp = bb;",
      "        bb = aa % tmp;",
      "        aa = tmp;",
      "    }",
      "    return aa;",
      "}"
    ]
  },
  "@inverse_mod": {
    "prefix": "@inverse_mod",
    "body": [
      "pub fn inverse_mod(element: usize, modulo: usize) -> usize {",
      "    assert!(1 <= modulo);",
      "    let i_element = element as i64;",
      "    let i_modulo = modulo as i64;",
      "    let (x, _) = extgcd(i_element, i_modulo);",
      "    let ans = ((x + i_modulo) % i_modulo) as usize;",
      "    assert!(ans * element % modulo == 1);",
      "    ans",
      "}",
      "pub fn extgcd(a: i64, b: i64) -> (i64, i64) {",
      "    if b == 0 {",
      "        return (1, 0);",
      "    }",
      "    let d = extgcd(b, a % b);",
      "    return (d.1, d.0 - a / b * d.1);",
      "}"
    ]
  },
  "@lcm": {
    "prefix": "@lcm",
    "body": [
      "pub fn gcd(a: usize, b: usize) -> usize {",
      "    let mut aa: usize = if a > b { a } else { b };",
      "    let mut bb: usize = if a > b { b } else { a };",
      "    while bb != 0 {",
      "        let tmp = bb;",
      "        bb = aa % tmp;",
      "        aa = tmp;",
      "    }",
      "    return aa;",
      "}",
      "pub fn lcm(a: usize, b: usize) -> usize {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  },
  "@next_permutation": {
    "prefix": "@next_permutation",
    "body": [
      "fn next_permutation<T: std::cmp::PartialOrd>(array: &mut [T]) -> Option<usize> {",
      "    let n = array.len();",
      "    if n < 2 {",
      "        return None;",
      "    }",
      "    let mut desc_begin_index = n - 1;",
      "    for i in (0..n - 1).rev() {",
      "        if array[i] <= array[i + 1] {",
      "            break;",
      "        }",
      "        desc_begin_index = i;",
      "    }",
      "    if desc_begin_index == 0 {",
      "        array.reverse();",
      "        return None;",
      "    }",
      "    desc_begin_index -= 1;",
      "    let pivot = &array[desc_begin_index];",
      "    let mut swap_to = n;",
      "    for i in (desc_begin_index..n).rev() {",
      "        if array[i] > *pivot {",
      "            swap_to = i;",
      "            break;",
      "        }",
      "    }",
      "    array.swap(desc_begin_index, swap_to);",
      "    array[desc_begin_index + 1..n].reverse();",
      "    Some(desc_begin_index)",
      "}"
    ]
  },
  "@permutation_mod": {
    "prefix": "@permutation_mod",
    "body": [
      "pub fn permutation_mod(m: usize, n: usize, modulo: usize) -> usize {",
      "    let mut numerator = 1;",
      "    for i in 0..n {",
      "        numerator *= m - i;",
      "        numerator %= modulo;",
      "    }",
      "    numerator",
      "}"
    ]
  },
  "@power_mod": {
    "prefix": "@power_mod",
    "body": [
      "pub fn power_mod(base: usize, exp: usize, modulo: usize) -> usize {",
      "    if exp == 0 {",
      "        return 1;",
      "    } else if exp & 1 == 0 {",
      "        return (power_mod(base, exp / 2, modulo) % modulo).pow(2) % modulo;",
      "    } else {",
      "        return power_mod(base, exp - 1, modulo) % modulo * base % modulo;",
      "    }",
      "}"
    ]
  },
  "@prev_permutation": {
    "prefix": "@prev_permutation",
    "body": [
      "fn prev_permutation<T: std::cmp::PartialOrd>(array: &mut [T]) -> Option<usize> {",
      "    let n = array.len();",
      "    if n < 2 {",
      "        return None;",
      "    }",
      "    let mut asc_begin_index = n - 1;",
      "    for i in (0..n - 1).rev() {",
      "        if array[i] >= array[i + 1] {",
      "            break;",
      "        }",
      "        asc_begin_index = i;",
      "    }",
      "    if asc_begin_index == 0 {",
      "        array.reverse();",
      "        return None;",
      "    }",
      "    asc_begin_index -= 1;",
      "    let pivot = &array[asc_begin_index];",
      "    let mut swap_to = n;",
      "    for i in (asc_begin_index..n).rev() {",
      "        if array[i] < *pivot {",
      "            swap_to = i;",
      "            break;",
      "        }",
      "    }",
      "    array.swap(asc_begin_index, swap_to);",
      "    array[asc_begin_index + 1..n].reverse();",
      "    Some(asc_begin_index)",
      "}"
    ]
  },
  "@prime_combination_mod": {
    "prefix": "@prime_combination_mod",
    "body": [
      "pub fn power_mod(base: usize, exp: usize, modulo: usize) -> usize {",
      "    if exp == 0 {",
      "        return 1;",
      "    } else if exp & 1 == 0 {",
      "        return (power_mod(base, exp / 2, modulo) % modulo).pow(2) % modulo;",
      "    } else {",
      "        return power_mod(base, exp - 1, modulo) % modulo * base % modulo;",
      "    }",
      "}",
      "pub fn prime_inverse_mod(element: usize, prime_modulo: usize) -> usize {",
      "    power_mod(element, prime_modulo - 2, prime_modulo) % prime_modulo",
      "}",
      "pub fn permutation_mod(m: usize, n: usize, modulo: usize) -> usize {",
      "    let mut numerator = 1;",
      "    for i in 0..n {",
      "        numerator *= m - i;",
      "        numerator %= modulo;",
      "    }",
      "    numerator",
      "}",
      "pub fn prime_combination_mod(m: usize, n: usize, prime_modulo: usize) -> usize {",
      "    let permutation = permutation_mod(m, n, prime_modulo);",
      "    let mut element = 1;",
      "    for j in 1..(n + 1) {",
      "        element *= j;",
      "        element %= prime_modulo;",
      "    }",
      "    permutation * prime_inverse_mod(element, prime_modulo) % prime_modulo",
      "}"
    ]
  },
  "@prime_factorize": {
    "prefix": "@prime_factorize",
    "body": [
      "fn eratosthenes(n: usize) -> Vec<usize> {",
      "    let mut sieve = Vec::with_capacity(n - 1);",
      "    for i in 2..=n {",
      "        sieve.push(i);",
      "    }",
      "    for i in 2..=(n as f64).sqrt() as usize {",
      "        if sieve[i - 2] < i {",
      "            continue;",
      "        }",
      "        for j in (i * i..=n).step_by(i) {",
      "            if sieve[j - 2] == j {",
      "                sieve[j - 2] = i;",
      "            }",
      "        }",
      "    }",
      "    let mut result = Vec::with_capacity(n - 1);",
      "    for i in 2..=n {",
      "        if sieve[i - 2] == i {",
      "            result.push(i);",
      "        }",
      "    }",
      "    result",
      "}",
      "fn prime_factorize(mut num: usize) -> std::collections::HashMap<usize, usize> {",
      "    let mut primes = eratosthenes(num);",
      "    let mut divisors = std::collections::HashMap::new();",
      "    let mut now = primes.len();",
      "    while num != 1 {",
      "        now -= 1;",
      "        let now_prime = primes[now];",
      "        let mut count = 0;",
      "        while num % now_prime == 0 {",
      "            num /= now_prime;",
      "            count += 1;",
      "        }",
      "        if count != 0 {",
      "            divisors.insert(now_prime, count);",
      "        }",
      "    }",
      "    divisors",
      "}"
    ]
  },
  "@prime_inverse_mod": {
    "prefix": "@prime_inverse_mod",
    "body": [
      "pub fn power_mod(base: usize, exp: usize, modulo: usize) -> usize {",
      "    if exp == 0 {",
      "        return 1;",
      "    } else if exp & 1 == 0 {",
      "        return (power_mod(base, exp / 2, modulo) % modulo).pow(2) % modulo;",
      "    } else {",
      "        return power_mod(base, exp - 1, modulo) % modulo * base % modulo;",
      "    }",
      "}",
      "pub fn prime_inverse_mod(element: usize, prime_modulo: usize) -> usize {",
      "    power_mod(element, prime_modulo - 2, prime_modulo) % prime_modulo",
      "}"
    ]
  },
  "@suffix_array": {
    "prefix": "@suffix_array",
    "body": [
      "pub fn suffix_array(s: &[char]) -> Vec<usize> {",
      "    let mut max_s_i = 0;",
      "    let s_i: Vec<usize> = s",
      "        .iter()",
      "        .map(|&c| {",
      "            let i = c as usize;",
      "            max_s_i = std::cmp::max(max_s_i, i);",
      "            i",
      "        })",
      "        .collect();",
      "    sa_is(&s_i, max_s_i)",
      "}",
      "fn sa_is(s_i: &[usize], max_s_i: usize) -> Vec<usize> {",
      "    let n = s_i.len();",
      "    match n {",
      "        0 => return vec![],",
      "        1 => return vec![0],",
      "        2 => {",
      "            return if s_i[0] < s_i[1] {",
      "                vec![0, 1]",
      "            } else {",
      "                vec![1, 0]",
      "            }",
      "        }",
      "        _ => (),",
      "    }",
      "    let mut is_L = vec![true; n];",
      "    for i in (0..n - 1).rev() {",
      "        is_L[i] = if s_i[i] == s_i[i + 1] {",
      "            is_L[i + 1]",
      "        } else {",
      "            s_i[i] >= s_i[i + 1]",
      "        };",
      "    }",
      "    let mut char_L_count = vec![0; max_s_i + 1];",
      "    let mut char_S_count = vec![0; max_s_i + 1];",
      "    for i in 0..n {",
      "        if is_L[i] {",
      "            char_L_count[s_i[i]] += 1;",
      "        } else {",
      "            char_S_count[s_i[i]] += 1;",
      "        }",
      "    }",
      "    let mut char_ranges = vec![(0, 0); max_s_i + 1];",
      "    let mut last = 0;",
      "    for c in 0..=max_s_i {",
      "        let c_total = char_L_count[c] + char_S_count[c];",
      "        if c_total != 0 {",
      "            char_ranges[c] = (last, last + c_total);",
      "            last += c_total;",
      "        }",
      "    }",
      "    let mut lms_index = vec![0; n];",
      "    let mut lms_count = 0;",
      "    for i in 1..n {",
      "        if is_L[i - 1] && !is_L[i] {",
      "            lms_count += 1;",
      "            lms_index[i] = lms_count;",
      "        }",
      "    }",
      "    let mut lms = Vec::with_capacity(lms_count);",
      "    for i in 1..n {",
      "        if lms_index[i] != 0 {",
      "            lms.push(i);",
      "        }",
      "    }",
      "    let mut sa = vec![0; n];",
      "    induced_sort(&mut sa, &s_i, &lms, &char_L_count, &char_ranges);",
      "    if lms_count > 0 {",
      "        let mut sorted_lms = Vec::with_capacity(lms_count);",
      "        for &i in &sa {",
      "            if lms_index[i - 1] != 0 {",
      "                sorted_lms.push(i - 1);",
      "            }",
      "        }",
      "        let mut lms_part_nums = vec![0; lms_count];",
      "        let mut max_lms_part_index = 0;",
      "        for i in 1..lms_count {",
      "            let lms1_start = sorted_lms[i - 1];",
      "            let lms1_end = if lms_index[lms1_start] == lms_count {",
      "                n",
      "            } else {",
      "                lms[lms_index[lms1_start]]",
      "            };",
      "            let lms2_start = sorted_lms[i];",
      "            let lms2_end = if lms_index[lms2_start] == lms_count {",
      "                n",
      "            } else {",
      "                lms[lms_index[lms2_start]]",
      "            };",
      "            let same = if (lms1_end - lms1_start) != (lms2_end - lms2_start) {",
      "                false",
      "            } else {",
      "                let mut same_all = true;",
      "                for o in 0..(lms1_end - lms1_start) {",
      "                    same_all = s_i[lms1_start + o] == s_i[lms2_start + o];",
      "                    if !same_all {",
      "                        break;",
      "                    }",
      "                }",
      "                same_all",
      "            };",
      "            if !same {",
      "                max_lms_part_index += 1;",
      "            }",
      "            lms_part_nums[lms_index[sorted_lms[i]] - 1] = max_lms_part_index;",
      "        }",
      "        let lms_part_sa = sa_is(&lms_part_nums, max_lms_part_index);",
      "        for i in 0..lms_count {",
      "            sorted_lms[i] = lms[lms_part_sa[i]];",
      "        }",
      "        induced_sort(&mut sa, &s_i, &sorted_lms, &char_L_count, &char_ranges);",
      "    }",
      "    sa.iter().map(|index1| index1 - 1).collect()",
      "}",
      "fn induced_sort(",
      "    sa: &mut [usize],",
      "    s_i: &[usize],",
      "    lms: &[usize],",
      "    char_L_count: &[usize],",
      "    char_ranges: &[(usize, usize)],",
      ") {",
      "    let n = s_i.len();",
      "    for i in sa.iter_mut() {",
      "        *i = 0;",
      "    }",
      "    let mut index_to_info = vec![(0, true); n];",
      "    let mut checked = vec![false; char_L_count.len()];",
      "    for i in 0..n {",
      "        let c = s_i[i];",
      "        let c_range = char_ranges[c];",
      "        let mut l_count = char_L_count[c];",
      "        if !checked[c] {",
      "            for j in c_range.0..c_range.1 {",
      "                let is_L = if l_count != 0 { true } else { false };",
      "                if l_count != 0 {",
      "                    l_count -= 1;",
      "                };",
      "                index_to_info[j] = (c, is_L);",
      "            }",
      "            checked[c] = true;",
      "        }",
      "    }",
      "    let mut now_char_index = vec![std::usize::MAX; char_L_count.len()];",
      "    for &i in lms.iter().rev() {",
      "        let c = s_i[i];",
      "        now_char_index[c] = if now_char_index[c] == std::usize::MAX {",
      "            char_ranges[c].1",
      "        } else {",
      "            now_char_index[c]",
      "        } - 1;",
      "        sa[now_char_index[c]] = i + 1;",
      "    }",
      "    let mut char_insert_count = vec![0; char_L_count.len()];",
      "    let c = s_i[n - 1];",
      "    sa[char_ranges[c].0 + char_insert_count[c]] = n;",
      "    char_insert_count[c] += 1;",
      "    for i in 0..n {",
      "        if sa[i] < 2 {",
      "            continue;",
      "        }",
      "        let target_index = sa[i] - 2;",
      "        let target_c = s_i[target_index];",
      "        let target_start_index = char_ranges[target_c].0;",
      "        let to_index = target_start_index + char_insert_count[target_c];",
      "        let to_is_L = index_to_info[to_index].1;",
      "        if to_is_L {",
      "            sa[to_index] = target_index + 1;",
      "            char_insert_count[target_c] += 1;",
      "        }",
      "    }",
      "    char_insert_count = vec![0; char_L_count.len()];",
      "    for i in (0..n).rev() {",
      "        if sa[i] < 2 {",
      "            continue;",
      "        }",
      "        let target_index = sa[i] - 2;",
      "        let target_c = s_i[target_index];",
      "        let target_end_index = char_ranges[target_c].1 - 1;",
      "        let to_index = target_end_index - char_insert_count[target_c];",
      "        let to_is_S = !index_to_info[to_index].1;",
      "        if to_is_S {",
      "            sa[to_index] = target_index + 1;",
      "            char_insert_count[target_c] += 1;",
      "        }",
      "    }",
      "}"
    ]
  },
  "@topological_sort_directed": {
    "prefix": "@topological_sort_directed",
    "body": [
      "fn topological_sort_directed_graph(n: usize, zeroIndexedEdges: &[(usize, usize)]) -> Vec<usize> {",
      "    let mut result = vec![];",
      "    let mut isolated = VecDeque::new();",
      "    let mut to = vec![vec![]; n];",
      "    let mut deg = vec![0; n + 1];",
      "    for e in zeroIndexedEdges {",
      "        to[e.0].push(e.1);",
      "        deg[e.1] += 1;",
      "    }",
      "    for i in 0..n {",
      "        if deg[i] == 0 {",
      "            isolated.push_front(i);",
      "        }",
      "    }",
      "    while isolated.len() != 0 {",
      "        let next = isolated.pop_back().unwrap();",
      "        result.push(next);",
      "        for i in &to[next] {",
      "            deg[*i] -= 1;",
      "            if deg[*i] == 0 {",
      "                isolated.push_front(*i);",
      "            }",
      "        }",
      "    }",
      "    result",
      "}"
    ]
  },
  "@topological_sort_undirected": {
    "prefix": "@topological_sort_undirected",
    "body": [
      "fn topological_sort_undirected_graph(n: usize, zeroIndexedEdges: &[(usize, usize)]) -> Vec<usize> {",
      "    let mut result = vec![];",
      "    let mut isolated = VecDeque::new();",
      "    let mut to = vec![vec![]; n];",
      "    let mut deg = vec![0; n + 1];",
      "    for e in zeroIndexedEdges {",
      "        to[e.0].push(e.1);",
      "        to[e.1].push(e.0);",
      "        deg[e.0] += 1;",
      "        deg[e.1] += 1;",
      "    }",
      "    for i in 0..n {",
      "        if deg[i] == 1 {",
      "            isolated.push_front(i);",
      "        }",
      "    }",
      "    while isolated.len() != 0 {",
      "        let next = isolated.pop_back().unwrap();",
      "        result.push(next);",
      "        for i in &to[next] {",
      "            deg[*i] -= 1;",
      "            if deg[*i] == 1 {",
      "                isolated.push_front(*i);",
      "            }",
      "        }",
      "    }",
      "    result",
      "}"
    ]
  },
  "@z_algorithm": {
    "prefix": "@z_algorithm",
    "body": [
      "pub fn z_algorithm(s: &[char]) -> Vec<usize> {",
      "    let mut z = vec![0; s.len()];",
      "    z[0] = s.len();",
      "    let mut i = 1;",
      "    let mut j = 0;",
      "    while i < s.len() {",
      "        while i + j < s.len() && s[j] == s[i + j] {",
      "            j += 1;",
      "        }",
      "        z[i] = j;",
      "        if j == 0 {",
      "            i += 1;",
      "            continue;",
      "        }",
      "        let mut k = 1;",
      "        while k < j && k + z[k] < j {",
      "            z[i + k] = z[k];",
      "            k += 1;",
      "        }",
      "        i += k;",
      "        j -= k;",
      "    }",
      "    z",
      "}"
    ]
  }
}
