{
  "@LazySegTree": {
    "prefix": "@LazySegTree",
    "body": [
      "pub struct LazySegTree<T: std::clone::Clone + std::fmt::Debug, U: std::clone::Clone> {",
      "    operation: fn(&T, &T) -> T,",
      "    effector: fn(&T, &U) -> T,",
      "    resolve_effect: fn(&U, &U) -> U,",
      "    segment_array: Vec<Option<T>>,",
      "    lazy_array: Vec<Option<U>>,",
      "    origin_length: usize,",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug, U: std::clone::Clone> LazySegTree<T, U> {",
      "    pub fn new(",
      "        array: Vec<T>,",
      "        operation: fn(&T, &T) -> T,",
      "        effector: fn(&T, &U) -> T,",
      "        resolve_effect: fn(&U, &U) -> U,",
      "    ) -> LazySegTree<T, U> {",
      "        let origin_length = array.len();",
      "        let mut all_array_length = 1;",
      "        while origin_length * 2 > all_array_length {",
      "            all_array_length <<= 1;",
      "        }",
      "        let mut segment_array: Vec<Option<T>> = vec![None; all_array_length];",
      "        let lazy_array: Vec<Option<U>> = vec![None; all_array_length];",
      "        let mut target_index = all_array_length >> 1;",
      "        for i in 0..origin_length {",
      "            segment_array[i + target_index] = Some(array[i].clone());",
      "        }",
      "        target_index -= 1;",
      "        while target_index != 0 {",
      "            let left_index = target_index << 1;",
      "            let right_index = (target_index << 1) + 1;",
      "            let value = if let Some(left) = &segment_array[left_index] {",
      "                if let Some(right) = &segment_array[right_index] {",
      "                    Some(operation(&left, &right))",
      "                } else {",
      "                    Some(left.clone())",
      "                }",
      "            } else {",
      "                if let Some(right) = &segment_array[right_index] {",
      "                    Some(right.clone())",
      "                } else {",
      "                    None",
      "                }",
      "            };",
      "            segment_array[target_index] = value;",
      "            target_index -= 1;",
      "        }",
      "        LazySegTree {",
      "            operation,",
      "            effector,",
      "            resolve_effect,",
      "            segment_array,",
      "            lazy_array,",
      "            origin_length: array.len(),",
      "        }",
      "    }",
      "    pub fn query(&mut self, start_index: usize, end_index: usize) -> T {",
      "        if start_index >= end_index {",
      "            panic!();",
      "        }",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let internal_start = origin_start_index + start_index;",
      "        let internal_end = origin_start_index + end_index - 1;",
      "        if internal_end >= origin_start_index + self.origin_length {",
      "            panic!();",
      "        }",
      "        return match self.resolve_effectcalc_section(internal_start, internal_end) {",
      "            Some(x) => x,",
      "            None => panic!(),",
      "        };",
      "    }",
      "    pub fn update(&mut self, index: usize, new_value: T) {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let mut target_index = origin_start_index + index;",
      "        self.segment_array[target_index] = Some(new_value);",
      "        target_index >>= 1;",
      "        while target_index != 0 {",
      "            let new_segment_value = if let Some(left) = &self.segment_array[target_index << 1] {",
      "                if let Some(right) = &self.segment_array[(target_index << 1) + 1] {",
      "                    let operation = self.operation;",
      "                    operation(&left, &right)",
      "                } else {",
      "                    left.clone()",
      "                }",
      "            } else {",
      "                panic!()",
      "            };",
      "            self.segment_array[target_index] = Some(new_segment_value);",
      "            target_index >>= 1;",
      "        }",
      "    }",
      "    pub fn range_effect(&mut self, start_index: usize, end_index: usize, effect: U) {",
      "        if start_index >= end_index {",
      "            panic!();",
      "        }",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let internal_start = origin_start_index + start_index;",
      "        let internal_end = origin_start_index + end_index - 1;",
      "        if internal_end >= origin_start_index + self.origin_length {",
      "            panic!();",
      "        }",
      "        self.resolve_effectapply_effector(internal_start, internal_end, &effect);",
      "    }",
      "    fn resolve_effectapply_effector(",
      "        &mut self,",
      "        internal_start: usize,",
      "        internal_end: usize,",
      "        effect: &U,",
      "    ) -> () {",
      "        if internal_start == internal_end {",
      "            self.resolve_effectapply_effector_lazy(internal_start, effect);",
      "        } else {",
      "            let section_and = internal_start & internal_end;",
      "            let end_offset = section_and ^ internal_end;",
      "            let xor_digits = 64 - end_offset.leading_zeros();",
      "            if xor_digits == end_offset.count_ones() {",
      "                let section_index = section_and >> xor_digits;",
      "                self.resolve_effectapply_effector_lazy(section_index, effect);",
      "            } else {",
      "                let left_end = section_and + (1 << (xor_digits - 1)) - 1;",
      "                let right_start = left_end + 1;",
      "                self.resolve_effectapply_effector(internal_start, left_end, effect);",
      "                self.resolve_effectapply_effector(right_start, internal_end, effect);",
      "            }",
      "        }",
      "    }",
      "    fn resolve_effectapply_effector_lazy(&mut self, lazy_index: usize, effect: &U) {",
      "        if let Some(x) = &self.lazy_array[lazy_index] {",
      "            let resolve_effect = self.resolve_effect;",
      "            self.lazy_array[lazy_index] = Some(resolve_effect(x, effect));",
      "        } else {",
      "            self.lazy_array[lazy_index] = Some(effect.clone());",
      "        }",
      "    }",
      "    fn resolve_effectcalc_section(",
      "        &mut self,",
      "        internal_start: usize,",
      "        internal_end: usize,",
      "    ) -> Option<T> {",
      "        if internal_start == internal_end {",
      "            return self.resolve_effectget_data(internal_start);",
      "        } else {",
      "            let section_and = internal_start & internal_end;",
      "            let end_offset = section_and ^ internal_end;",
      "            let xor_digits = 64 - end_offset.leading_zeros();",
      "            if xor_digits == end_offset.count_ones() {",
      "                let section_index = section_and >> xor_digits;",
      "                return self.resolve_effectget_data(section_index);",
      "            } else {",
      "                let left_end = section_and + (1 << (xor_digits - 1)) - 1;",
      "                let right_start = left_end + 1;",
      "                let left = self.resolve_effectcalc_section(internal_start, left_end);",
      "                let right = self.resolve_effectcalc_section(right_start, internal_end);",
      "                self.operation(left, right)",
      "            }",
      "        }",
      "    }",
      "    fn resolve_effectget_data(&mut self, internal_index: usize) -> Option<T> {",
      "        if let Some(value) = &self.segment_array[internal_index] {",
      "            let origin_start_index = self.segment_array.len() >> 1;",
      "            if let Some(effect) = &self.lazy_array[internal_index] {",
      "                if internal_index >= origin_start_index {",
      "                    let effector = self.effector;",
      "                    self.segment_array[internal_index] = Some(effector(value, effect));",
      "                } else {",
      "                    let left_index = internal_index << 1;",
      "                    let right_index = (internal_index << 1) + 1;",
      "                    let effect = effect.clone();",
      "                    self.resolve_effectapply_effector_lazy(left_index, &effect);",
      "                    self.resolve_effectapply_effector_lazy(right_index, &effect);",
      "                    let left = self.resolve_effectget_data(left_index);",
      "                    let right = self.resolve_effectget_data(right_index);",
      "                    self.segment_array[internal_index] = self.operation(left, right);",
      "                }",
      "                self.lazy_array[internal_index] = None;",
      "            } else {",
      "                if internal_index >= origin_start_index {",
      "                } else {",
      "                    let left_index = internal_index << 1;",
      "                    let right_index = (internal_index << 1) + 1;",
      "                    let left = self.resolve_effectget_data(left_index);",
      "                    let right = self.resolve_effectget_data(right_index);",
      "                    self.segment_array[internal_index] = self.operation(left, right);",
      "                }",
      "            }",
      "        }",
      "        self.segment_array[internal_index].clone()",
      "    }",
      "    fn operation(&self, left: Option<T>, right: Option<T>) -> Option<T> {",
      "        if let Some(left) = left {",
      "            if let Some(right) = right {",
      "                let operation = self.operation;",
      "                return Some(operation(&left, &right));",
      "            } else {",
      "                return Some(left);",
      "            }",
      "        } else {",
      "            panic!()",
      "        }",
      "    }",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug, U: std::clone::Clone> std::fmt::Debug",
      "    for LazySegTree<T, U>",
      "{",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let target_slice: Vec<_> = self.segment_array[origin_start_index..]",
      "            .iter()",
      "            .filter(|&element| {",
      "                if element.is_some() {",
      "                    return true;",
      "                } else {",
      "                    return false;",
      "                }",
      "            })",
      "            .map(|element| element.as_ref().unwrap().clone())",
      "            .collect();",
      "        f.debug_list().entries(&target_slice).finish()",
      "    }",
      "}"
    ]
  },
  "@SegTree": {
    "prefix": "@SegTree",
    "body": [
      "pub struct SegTree<T: std::clone::Clone + std::fmt::Debug> {",
      "    operation: fn(&T, &T) -> T,",
      "    segment_array: Vec<Option<T>>,",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug> SegTree<T> {",
      "    pub fn new(array: Vec<T>, operation: fn(&T, &T) -> T) -> SegTree<T> {",
      "        let origin_length = array.len();",
      "        let mut all_array_length = 1;",
      "        while origin_length * 2 > all_array_length {",
      "            all_array_length <<= 1;",
      "        }",
      "        let mut segment_array: Vec<Option<T>> = vec![None; all_array_length];",
      "        let mut target_index = all_array_length >> 1;",
      "        for i in 0..origin_length {",
      "            segment_array[i + target_index] = Some(array[i].clone());",
      "        }",
      "        target_index -= 1;",
      "        while target_index != 0 {",
      "            let left_index = target_index << 1;",
      "            let right_index = (target_index << 1) + 1;",
      "            let value = if let Some(left) = &segment_array[left_index] {",
      "                if let Some(right) = &segment_array[right_index] {",
      "                    Some(operation(&left, &right))",
      "                } else {",
      "                    Some(left.clone())",
      "                }",
      "            } else {",
      "                if let Some(right) = &segment_array[right_index] {",
      "                    Some(right.clone())",
      "                } else {",
      "                    None",
      "                }",
      "            };",
      "            segment_array[target_index] = value;",
      "            target_index -= 1;",
      "        }",
      "        SegTree {",
      "            operation,",
      "            segment_array,",
      "        }",
      "    }",
      "    pub fn query(&self, start_index: usize, end_index: usize) -> T {",
      "        if start_index >= end_index {",
      "            panic!();",
      "        }",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let internal_start = origin_start_index + start_index;",
      "        let internal_end = origin_start_index + end_index - 1;",
      "        return match self.calc_section(internal_start, internal_end) {",
      "            Some(x) => x,",
      "            None => panic!(),",
      "        };",
      "    }",
      "    pub fn update(&mut self, index: usize, new_value: T) {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let mut target_index = origin_start_index + index;",
      "        self.segment_array[target_index] = Some(new_value);",
      "        target_index >>= 1;",
      "        while target_index != 0 {",
      "            let new_segment_value = if let Some(left) = &self.segment_array[target_index << 1] {",
      "                if let Some(right) = &self.segment_array[(target_index << 1) + 1] {",
      "                    let operation = self.operation;",
      "                    operation(&left, &right)",
      "                } else {",
      "                    left.clone()",
      "                }",
      "            } else {",
      "                panic!()",
      "            };",
      "            self.segment_array[target_index] = Some(new_segment_value);",
      "            target_index >>= 1;",
      "        }",
      "    }",
      "    fn calc_section(&self, internal_start: usize, internal_end: usize) -> Option<T> {",
      "        if internal_start == internal_end {",
      "            return self.segment_array[internal_start].clone();",
      "        } else {",
      "            let section_and = internal_start & internal_end;",
      "            let end_offset = section_and ^ internal_end;",
      "            let xor_digits = 64 - end_offset.leading_zeros();",
      "            if xor_digits == end_offset.count_ones() {",
      "                let section_index = section_and >> xor_digits;",
      "                return self.segment_array[section_index].clone();",
      "            } else {",
      "                let left_end = section_and + (1 << (xor_digits - 1)) - 1;",
      "                let right_start = left_end + 1;",
      "                if let Some(left) = self.calc_section(internal_start, left_end) {",
      "                    if let Some(right) = self.calc_section(right_start, internal_end) {",
      "                        let operation = self.operation;",
      "                        return Some(operation(&left, &right));",
      "                    } else {",
      "                        return Some(left);",
      "                    }",
      "                } else {",
      "                    panic!()",
      "                }",
      "            }",
      "        }",
      "    }",
      "}",
      "impl<T: std::clone::Clone + std::fmt::Debug> std::fmt::Debug for SegTree<T> {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        let origin_start_index = self.segment_array.len() >> 1;",
      "        let target_slice: Vec<_> = self.segment_array[origin_start_index..]",
      "            .iter()",
      "            .filter(|&element| {",
      "                if element.is_some() {",
      "                    return true;",
      "                } else {",
      "                    return false;",
      "                }",
      "            })",
      "            .map(|element| element.as_ref().unwrap().clone())",
      "            .collect();",
      "        f.debug_list().entries(&target_slice).finish()",
      "    }",
      "}"
    ]
  },
  "@combination_mod": {
    "prefix": "@combination_mod",
    "body": [
      "fn power_mod(base: usize, exp: usize, modulo: usize) -> usize {",
      "    if exp == 0 {",
      "        return 1;",
      "    } else if exp & 1 == 0 {",
      "        return (power_mod(base, exp / 2, modulo) % modulo).pow(2) % modulo;",
      "    } else {",
      "        return power_mod(base, exp - 1, modulo) % modulo * base % modulo;",
      "    }",
      "}",
      "fn inverse_mod(element: usize, prime_modulo: usize) -> usize {",
      "    power_mod(element, prime_modulo - 2, prime_modulo) % prime_modulo",
      "}",
      "fn permutation_mod(m: usize, n: usize, prime_modulo: usize) -> usize {",
      "    let mut numerator = 1;",
      "    for i in 0..n {",
      "        numerator *= m - i;",
      "        numerator %= prime_modulo;",
      "    }",
      "    numerator",
      "}",
      "fn combination_mod(m: usize, n: usize, prime_modulo: usize) -> usize {",
      "    let permutation = permutation_mod(m, n, prime_modulo);",
      "    let mut element = 1;",
      "    for j in 1..(n + 1) {",
      "        element *= j;",
      "        element %= prime_modulo;",
      "    }",
      "    permutation * inverse_mod(element, prime_modulo) % prime_modulo",
      "}"
    ]
  },
  "@gcd": {
    "prefix": "@gcd",
    "body": [
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    let mut aa: u64 = if a > b { a } else { b };",
      "    let mut bb: u64 = if a > b { b } else { a };",
      "    while bb != 0 {",
      "        let tmp = bb;",
      "        bb = aa % tmp;",
      "        aa = tmp;",
      "    }",
      "    return aa;",
      "}"
    ]
  },
  "@inverse_mod": {
    "prefix": "@inverse_mod",
    "body": [
      "fn power_mod(base: usize, exp: usize, modulo: usize) -> usize {",
      "    if exp == 0 {",
      "        return 1;",
      "    } else if exp & 1 == 0 {",
      "        return (power_mod(base, exp / 2, modulo) % modulo).pow(2) % modulo;",
      "    } else {",
      "        return power_mod(base, exp - 1, modulo) % modulo * base % modulo;",
      "    }",
      "}",
      "fn inverse_mod(element: usize, prime_modulo: usize) -> usize {",
      "    power_mod(element, prime_modulo - 2, prime_modulo) % prime_modulo",
      "}"
    ]
  },
  "@lcm": {
    "prefix": "@lcm",
    "body": [
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    let mut aa: u64 = if a > b { a } else { b };",
      "    let mut bb: u64 = if a > b { b } else { a };",
      "    while bb != 0 {",
      "        let tmp = bb;",
      "        bb = aa % tmp;",
      "        aa = tmp;",
      "    }",
      "    return aa;",
      "}",
      "fn lcm(a: u64, b: u64) -> u64 {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  },
  "@power_mod": {
    "prefix": "@power_mod",
    "body": [
      "fn power_mod(base: usize, exp: usize, modulo: usize) -> usize {",
      "    if exp == 0 {",
      "        return 1;",
      "    } else if exp & 1 == 0 {",
      "        return (power_mod(base, exp / 2, modulo) % modulo).pow(2) % modulo;",
      "    } else {",
      "        return power_mod(base, exp - 1, modulo) % modulo * base % modulo;",
      "    }",
      "}"
    ]
  }
}
